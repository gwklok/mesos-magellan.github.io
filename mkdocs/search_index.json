{
    "docs": [
        {
            "location": "/", 
            "text": "Magellan\n\n\nA Mesos framework for Distributed Simulated Annealing.\n\n\nComponents\n\n\nFaleiro (The Scheduler)\n\n\nEnrique (The Executor)\n\n\nMiguel (The Scheduler CLI)\n\n\nVictoria (Development Environment)\n\n\nTraveling Sailor (TSP Solver using Simulated Annealing)\n\n\nCircumnavigator (Web User Interface)", 
            "title": "Home"
        }, 
        {
            "location": "/#magellan", 
            "text": "A Mesos framework for Distributed Simulated Annealing.", 
            "title": "Magellan"
        }, 
        {
            "location": "/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/#faleiro-the-scheduler", 
            "text": "", 
            "title": "Faleiro (The Scheduler)"
        }, 
        {
            "location": "/#enrique-the-executor", 
            "text": "", 
            "title": "Enrique (The Executor)"
        }, 
        {
            "location": "/#miguel-the-scheduler-cli", 
            "text": "", 
            "title": "Miguel (The Scheduler CLI)"
        }, 
        {
            "location": "/#victoria-development-environment", 
            "text": "", 
            "title": "Victoria (Development Environment)"
        }, 
        {
            "location": "/#traveling-sailor-tsp-solver-using-simulated-annealing", 
            "text": "", 
            "title": "Traveling Sailor (TSP Solver using Simulated Annealing)"
        }, 
        {
            "location": "/#circumnavigator-web-user-interface", 
            "text": "", 
            "title": "Circumnavigator (Web User Interface)"
        }, 
        {
            "location": "/components/", 
            "text": "Components\n\n\nA detailed description of all the components that makes up the Magellan Mesos Framework.\n\n\nWeb UI (Circumnavigator)\n\n\nThe Web User Interface (UI) allows users to create, manage, and monitor jobs. It is built using jQuery, Bootstrap and pure.js. To connect to the scheduler API, AJAX calls are made to create, modify and retrieve jobs. Bootstrap was used for quick styling and ensuring consistent functionality and appearence across different devices and browsers. pure.js allowed for templating HTML code with scheduler API data.\n\n\nThere are 3 pages to the web UI: Job List (home page), Create a Job, and Job Details. Each page has its own JavaScript file in the js folder, as well as a global script file: script.js, which holds global functions and data. The job list and job details pages auto-refresh periodically to keep the user updated with accurate information. The create a job page validates the user's input, providing feedback on incorrect fields, and redirects the user to the job details page for the job they create.\n\n\nState-based colour feedback is used throughout the UI. Based on the status of the job, different elements will have different colours or be hidden. The progress bar's appearance differs based on state in colour, animation, and style. When the job is in a state that could allow for completion (RUNNING or PAUSED), the progress bar is animated with moving stripes. When the job is in a state where it is incomplete and will not be able to be completed (STOP or FAILED), the progress bar is no longer animated but is still striped. Once the job is DONE, the progress bar is a solid green. The progress bars have a minimum width to correctly display the progress percentage when the values are low. The action buttons on the job details page are dynamic to the state as well. Their colours correspond to the actions they perform and will be hidden if their action is not valid for the current state.\n\n\nThe job list is ordered from newest to oldest descending with all stored jobs being displayed. The status and progress bars are styled as described above.\n\n\nScheduler REST API (Faleiro API)\n\n\nCreating a Job\n\n\nThe Web API receives input as documented on the Web API Schema page. It then validates user input as necessary and forwards the input to an instance of the scheduler framework. To create a job, the API forwards the parameters to the \nMagellanFramework::createJob()\n method which then returns the created job's ID and returns it to the user making the API request.\n\n\nGetting Job Status\n\n\nWhen the user requests data about the running jobs, the web API calls the \nMagellanFramework::getSimpleJobStatus()\n and \nMagellanFramework::getSimpleAllJobStatuses()\n methods for a specific job and for all jobs, respectively. The method calls provide all the info about a job which is then returned to the user.\n\n\nManage a Job\n\n\nThe Web API is able to pause, resume, and stop a job. The user makes a request and specificies which action they would like to take. The Web API then makes the appropriate method call to the scheduler framework: \nMagellanFramework::pauseJob()\n, \nMagellanFramework::resumeJob()\n, and \nMagellanFramework::stopJob()\n.\n\n\nScheduler Backend (Faleiro)\n\n\nFaleiro is the code name for our scheduler. Our scheduler is controlled from our web api and is responsible for accepting resource offers from the Mesos master, collecting tasks to be scheduled from active jobs, and choosing and running a subset of these jobs on availble resource offers. \n\n\nResource Offers\n\n\nOnce the scheduler has registered with the Mesos Master, the Master provides fine grained access to machine resources (such CPU, RAM) availble in the cluster to the scheduler by sending resource offers. Schedulers will then use these resource offers to run tasks. The Master sends resource offers asynchronously to the scheduler by calling \nMagellanFramework::resourceOffers()\n and the scheduler stores these resource offers in a \nBlockingQueue\n. These received resource offers are then given to Fenzo inside the framework's main loop (see sections on \"Fenzo\" and \"Framework Main Loop\").  \n\n\nFenzo\n\n\nFenzo is a java library provided by Netflix that essentially takes care of the bin packing problem for us. In other words, given a list of tasks to run and a list of resource offers, find the most efficient pairings between tasks and resource offers.  Although we could have used a simple, greedy algorithm of pairing the first task in our queue with the first resource offer received, this approach not only scales terribly, but also doesn't take into account the heterogeneous nature of the tasks and resource offers. Each task could require different amounts of system resources to run and mixed constraints. By using fenzo, we can acheive scheduling optimizations and autoscaling the cluster based on usage. \n\n\nOn each run of the MagellanFramework main loop, the framework invokes Fenzo's bin backing functionality by calling \nTaskScheduler::scheduleOnce()\n and providing it with a list of resource offers received from \nMagellanFramework::resourceOffers()\n and tasks to schedule which is attained by calling \nMagellanJob::getPendingTasks()\n. If resource offers are not used by fenzo in the current itertation of the Framework's main loop, it keeps hold of them and are re-used on the next call to \nTaskScheduler::scheduleOnce()\n.\n\n\nZookeeper\n\n\nZookeeper is a service provided by Apache that provides synchronization and maintains configuration information reliably across a distributed cluster. In our system, Zookeeper is responsible for providing high availability (HA) by performing two services: leader election and persisting scheduler state.\n\n\nYou can find more information on the specifics of Zookeeper here (http://zookeeper.apache.org/doc/r3.3.3/zookeeperProgrammers.html#_introduction) but here are the essentials:\n\n\nZookeeper consists of a hierarchal namespace much like a file system. The only difference is that each node can have data as well as having children\n\n\nLeader Election\n\n\nIn order to ensure that our cluster is resilient to schedulers crashing, we introduced a system with multiple schedulers. The idea is that one of these schedulers will be the leader and coordinate all the various functions of a scheduler while the other \"follower\" schedulers will wait in idle until the lead scheduler goes down for any reason . When the leader goes down, the remaining, idle schedulers will undergo the process of leader election by confering among themselves and electing a new scheduler as the leader. This new leader will be responsible for restoring the state of the system to where it was before the first leader crashed. This entails re-enabling the web endpoints to communicate with our web UI, open a new connection with the Mesos master and restarting jobs that were running previously. \n\n\nThe process of electing a leader is done by levereging Zookeeper's to synchronize and coordinate concurrent writes.\n\n\nFramework Main Loop\n\n\nThe main loop of the MagellanFramework is run in a separate thread which calls the function \nMagellanFramework::runFramework()\n. This function first loops through the list of running jobs in the system and calls \nMagellanJob::getPendingTasks()\n on each job to get a list of tasks it wants to schedule. It then gives this list to Fenzo by calling \nTaskScheduler::scheduleOnce()\n and receives a mapping between resource offers and tasks. If some of the tasks are not selected to be scheduled by Fenzo, then the remaining tasks are retained by the Framework and are submitted to Fenzo again during the next iteration. \n\n\nAfter receiving the scheduling suggestions by Fenzo,the the framework then prepares each task by creating a \nTaskInfo\n object which contains information such as the slave ID and task data. Tasks are scheduled on a per Host (node) basis. Hosts are specified using the \nVMAssignmentResult\n object and can offer multiple resource offers (called \nleases\n in the code). A list of all TaskInfo object for each host is created in an object called \ntaskInfos\n. Additionally, a list of all the resource offer ids that will be used on the particular host are created and stored in a list called \nofferIDs\n. Once the \ntaskInfos\n and \nofferIDs\n objects are populated, they are submitted to the mesos driver using the method, \nMesosSchedulerDriver::launchTasks()\n. The mesos driver is responsible for getting the tasks to their corresponding executor.", 
            "title": "Components"
        }, 
        {
            "location": "/components/#components", 
            "text": "A detailed description of all the components that makes up the Magellan Mesos Framework.", 
            "title": "Components"
        }, 
        {
            "location": "/components/#web-ui-circumnavigator", 
            "text": "The Web User Interface (UI) allows users to create, manage, and monitor jobs. It is built using jQuery, Bootstrap and pure.js. To connect to the scheduler API, AJAX calls are made to create, modify and retrieve jobs. Bootstrap was used for quick styling and ensuring consistent functionality and appearence across different devices and browsers. pure.js allowed for templating HTML code with scheduler API data.  There are 3 pages to the web UI: Job List (home page), Create a Job, and Job Details. Each page has its own JavaScript file in the js folder, as well as a global script file: script.js, which holds global functions and data. The job list and job details pages auto-refresh periodically to keep the user updated with accurate information. The create a job page validates the user's input, providing feedback on incorrect fields, and redirects the user to the job details page for the job they create.  State-based colour feedback is used throughout the UI. Based on the status of the job, different elements will have different colours or be hidden. The progress bar's appearance differs based on state in colour, animation, and style. When the job is in a state that could allow for completion (RUNNING or PAUSED), the progress bar is animated with moving stripes. When the job is in a state where it is incomplete and will not be able to be completed (STOP or FAILED), the progress bar is no longer animated but is still striped. Once the job is DONE, the progress bar is a solid green. The progress bars have a minimum width to correctly display the progress percentage when the values are low. The action buttons on the job details page are dynamic to the state as well. Their colours correspond to the actions they perform and will be hidden if their action is not valid for the current state.  The job list is ordered from newest to oldest descending with all stored jobs being displayed. The status and progress bars are styled as described above.", 
            "title": "Web UI (Circumnavigator)"
        }, 
        {
            "location": "/components/#scheduler-rest-api-faleiro-api", 
            "text": "", 
            "title": "Scheduler REST API (Faleiro API)"
        }, 
        {
            "location": "/components/#creating-a-job", 
            "text": "The Web API receives input as documented on the Web API Schema page. It then validates user input as necessary and forwards the input to an instance of the scheduler framework. To create a job, the API forwards the parameters to the  MagellanFramework::createJob()  method which then returns the created job's ID and returns it to the user making the API request.", 
            "title": "Creating a Job"
        }, 
        {
            "location": "/components/#getting-job-status", 
            "text": "When the user requests data about the running jobs, the web API calls the  MagellanFramework::getSimpleJobStatus()  and  MagellanFramework::getSimpleAllJobStatuses()  methods for a specific job and for all jobs, respectively. The method calls provide all the info about a job which is then returned to the user.", 
            "title": "Getting Job Status"
        }, 
        {
            "location": "/components/#manage-a-job", 
            "text": "The Web API is able to pause, resume, and stop a job. The user makes a request and specificies which action they would like to take. The Web API then makes the appropriate method call to the scheduler framework:  MagellanFramework::pauseJob() ,  MagellanFramework::resumeJob() , and  MagellanFramework::stopJob() .", 
            "title": "Manage a Job"
        }, 
        {
            "location": "/components/#scheduler-backend-faleiro", 
            "text": "Faleiro is the code name for our scheduler. Our scheduler is controlled from our web api and is responsible for accepting resource offers from the Mesos master, collecting tasks to be scheduled from active jobs, and choosing and running a subset of these jobs on availble resource offers.", 
            "title": "Scheduler Backend (Faleiro)"
        }, 
        {
            "location": "/components/#resource-offers", 
            "text": "Once the scheduler has registered with the Mesos Master, the Master provides fine grained access to machine resources (such CPU, RAM) availble in the cluster to the scheduler by sending resource offers. Schedulers will then use these resource offers to run tasks. The Master sends resource offers asynchronously to the scheduler by calling  MagellanFramework::resourceOffers()  and the scheduler stores these resource offers in a  BlockingQueue . These received resource offers are then given to Fenzo inside the framework's main loop (see sections on \"Fenzo\" and \"Framework Main Loop\").", 
            "title": "Resource Offers"
        }, 
        {
            "location": "/components/#fenzo", 
            "text": "Fenzo is a java library provided by Netflix that essentially takes care of the bin packing problem for us. In other words, given a list of tasks to run and a list of resource offers, find the most efficient pairings between tasks and resource offers.  Although we could have used a simple, greedy algorithm of pairing the first task in our queue with the first resource offer received, this approach not only scales terribly, but also doesn't take into account the heterogeneous nature of the tasks and resource offers. Each task could require different amounts of system resources to run and mixed constraints. By using fenzo, we can acheive scheduling optimizations and autoscaling the cluster based on usage.   On each run of the MagellanFramework main loop, the framework invokes Fenzo's bin backing functionality by calling  TaskScheduler::scheduleOnce()  and providing it with a list of resource offers received from  MagellanFramework::resourceOffers()  and tasks to schedule which is attained by calling  MagellanJob::getPendingTasks() . If resource offers are not used by fenzo in the current itertation of the Framework's main loop, it keeps hold of them and are re-used on the next call to  TaskScheduler::scheduleOnce() .", 
            "title": "Fenzo"
        }, 
        {
            "location": "/components/#zookeeper", 
            "text": "Zookeeper is a service provided by Apache that provides synchronization and maintains configuration information reliably across a distributed cluster. In our system, Zookeeper is responsible for providing high availability (HA) by performing two services: leader election and persisting scheduler state.  You can find more information on the specifics of Zookeeper here (http://zookeeper.apache.org/doc/r3.3.3/zookeeperProgrammers.html#_introduction) but here are the essentials:  Zookeeper consists of a hierarchal namespace much like a file system. The only difference is that each node can have data as well as having children", 
            "title": "Zookeeper"
        }, 
        {
            "location": "/components/#leader-election", 
            "text": "In order to ensure that our cluster is resilient to schedulers crashing, we introduced a system with multiple schedulers. The idea is that one of these schedulers will be the leader and coordinate all the various functions of a scheduler while the other \"follower\" schedulers will wait in idle until the lead scheduler goes down for any reason . When the leader goes down, the remaining, idle schedulers will undergo the process of leader election by confering among themselves and electing a new scheduler as the leader. This new leader will be responsible for restoring the state of the system to where it was before the first leader crashed. This entails re-enabling the web endpoints to communicate with our web UI, open a new connection with the Mesos master and restarting jobs that were running previously.   The process of electing a leader is done by levereging Zookeeper's to synchronize and coordinate concurrent writes.", 
            "title": "Leader Election"
        }, 
        {
            "location": "/components/#framework-main-loop", 
            "text": "The main loop of the MagellanFramework is run in a separate thread which calls the function  MagellanFramework::runFramework() . This function first loops through the list of running jobs in the system and calls  MagellanJob::getPendingTasks()  on each job to get a list of tasks it wants to schedule. It then gives this list to Fenzo by calling  TaskScheduler::scheduleOnce()  and receives a mapping between resource offers and tasks. If some of the tasks are not selected to be scheduled by Fenzo, then the remaining tasks are retained by the Framework and are submitted to Fenzo again during the next iteration.   After receiving the scheduling suggestions by Fenzo,the the framework then prepares each task by creating a  TaskInfo  object which contains information such as the slave ID and task data. Tasks are scheduled on a per Host (node) basis. Hosts are specified using the  VMAssignmentResult  object and can offer multiple resource offers (called  leases  in the code). A list of all TaskInfo object for each host is created in an object called  taskInfos . Additionally, a list of all the resource offer ids that will be used on the particular host are created and stored in a list called  offerIDs . Once the  taskInfos  and  offerIDs  objects are populated, they are submitted to the mesos driver using the method,  MesosSchedulerDriver::launchTasks() . The mesos driver is responsible for getting the tasks to their corresponding executor.", 
            "title": "Framework Main Loop"
        }, 
        {
            "location": "/comm/", 
            "text": "Communication\n\n\nDescription of the communication between the different components of the Magellan Mesos Framework.\n\n\nThe Scheduler API Schema\n\n\nThe following REST API schema is used by the Web UI to communicate with the scheduler back end.\n\n\nPOST /api/job\n\n\nCreate a new job\n\n\nRequest\n\n\n{\n    \njob_name\n : \nSolve 99 Problems\n,\n    \njob_time\n : 3600,\n    \nmodule_url\n : \ngit@github.com:mesos-magellan/faleiro.git\n,\n    \nmodule_data\n : {\n        \nproblem_size\n : 99,\n        \nexpected_solution\n : 0,\n        \nanything_i_want\n : {\n            \nall_my_things\n : [\n                \ncat\n,\n                4096,\n                \ndogs\n,\n                \nfoo\n\n            ]\n        }\n    }\n}\n\n\n\n\nResponse (200)\n\n\n{\n    \njob_id\n : 42\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}\n\n\n\n\nResponse (500)\n\n\n{\n    \nmessage\n : \nFailed to create job\n\n}\n\n\n\n\nPUT /api/job/{job_id}/status\n\n\nSet the status of an existing job\n\n\nParameters\n\n\n{job_id}\n : \nID of the job to modify\n\n\nRequest\n\n\n{\n    \nstatus\n : \nresume\n /* or \nstop\n or \npause\n */\n}\n\n\n\n\nResponse (200)\n\n\n{\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}\n\n\n\n\nGET /api/jobs\n\n\nGet all the jobs\n\n\nRequest\n\n\n{\n}\n\n\n\n\nResponse (200)\n\n\n{\n    [\n        {\n            \njob_id\n : 42,\n            \njob_name\n : \nSolve 99 Problems\n,\n            \njob_starting_time\n : 112385801,\n            \ntask_name\n : \ngit@github.com:mesos-magellan/faleiro.git\n,\n            \ntask_seconds\n : 500,\n            \ncurrent_state\n : \nRUNNING\n,\n            \nbest_location\n : \n{ \\\npath\\\n : \\\nSUJENAGHWOPQ\\\n }\n,\n            \nbest_energy\n : 400.5,\n            \nnum_finished_tasks\n : 91,\n            \nnum_total_tasks\n : 99,\n            \nenergy_history\n : [\n                0.2,\n                400.5,\n                10.122\n            ],\n            \nadditional_params\n : {\n                \nstart\n : {\n                    \nX\n : 356,\n                    \nname\n : \nfoo\n\n                }\n            }\n        },\n        {\n            \njob_id\n : 47,\n            \njob_name\n : \nSolve All Problems\n,\n            \njob_starting_time\n : 112385801,\n            \ntask_name\n : \ngit@github.com:mesos-magellan/faleiro.git\n,\n            \ntask_seconds\n : 600,\n            \ncurrent_state\n : \nSTOP\n,\n            \nbest_location\n : \n{ \\\nindex\\\n : 2345093 }\n,\n            \nbest_energy\n : 12039454,\n            \nnum_finished_tasks\n : 42,\n            \nnum_total_tasks\n : 123,\n            \nenergy_history\n : [\n                947345,\n                3302,\n                12039454\n            ],\n            \nadditional_params\n : {\n                \nstart\n : {\n                    \nX\n : 50,\n                    \nname\n : \nhello world\n\n                }\n            }\n        }\n    ]\n}\n\n\n\n\nGET /api/job/{job_id}\n\n\nGet a specific job by job_id\n\n\nParameters\n\n\n{job_id}\n : \nID of the job to retrieve\n\n\nRequest\n\n\n{\n}\n\n\n\n\nResponse (200) - No longer running\n\n\nResponse (202) - Job still running\n\n\n{\n    \njob_id\n : 47,\n    \njob_name\n : \nSolve All Problems\n,\n    \njob_starting_time\n : 112385801,\n    \ntask_name\n : \ngit@github.com:mesos-magellan/faleiro.git\n,\n    \ntask_seconds\n : 600,\n    \ncurrent_state\n : \nSTOP\n,\n    \nbest_location\n : \n{ \\\nindex\\\n : 2345093 }\n,\n    \nbest_energy\n : 12039454,\n    \nnum_finished_tasks\n : 42,\n    \nnum_total_tasks\n : 123,\n    \nenergy_history\n : [\n        947345,\n        3302,\n        12039454\n    ],\n    \nadditional_params\n : {\n        \nstart\n : {\n            \nX\n : 50,\n            \nname\n : \nhello world\n\n        }\n    }\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}\n\n\n\n\nJob Creation to Executor\n\n\nClient Starts Job\n\n\nThe client starts a job using the command line interface. Using the CLI, they can specify the parameters for their job. The full list of parameters can be found on the Web API page. After creating a job on the command line client, the request is sent to the Web API using http.\n\n\nThe Web API\n\n\nThe web api handles the request from the CLI and forwards this request to the MagellanFramework using the function call \nMagellanFramework::createJob()\n. \n\n\nThe Magellan Framework\n\n\nInternally, the Magellan Framework constructs a MagellanJob object. A MagellanJob, at a high level, represents all data and state corresponding to a problem that the client wants to solve. The MagellanJob breaks this problem into subproblems called tasks which are run on executors. An instance of the Magellan Framework can have multiple instances of MagellanJob with each instance having several tasks associated with it that can be run in parallel.  After creating the MagellanJob object, the framework calls \nMagellanJob::start()\n which executes the main function of the Job, called \nMagellanJob::run()\n, in a separate thread. \n\n\nA MagellanJob is responsible for partioning the search space of the problem and creating tasks which run on executors and report their results back to the job. MagellanJobs are restricted to creating 10 active tasks at a time to ensure that this system scales well when a lot of jobs are submitted simultaneously. New tasks are submitted to a BlockingQueue called \npendingTasks\n. This object holds ready tasks until the MagellanFramework requests them using the method \nMagellanJob::getPendingTasks()\n. After executing tasks, the results are returned to the Job to be processed using the method, \nMagellanJob::processIncomingMessages()\n. \n\n\nThe scheduler sends the following JSON string to the executor as part of the tasks payload: \n\n\n{\n    # required\n    \nuid\n:\n    \nname\n:\n    \ncommand\n:\n    \nproblem_data\n:\n    # for 'divisions' command\n    \ndivisions\n:\n    # for 'anneal' command\n    \nsstates\n:\n    \nminutes_per_division\n:\n}\n\n\n\n\nAs you can see, each task only sends a unique identifier for the task, the starting location for the simulated annealing (SA) algorithm, the name of the SA implementation we want to use to execute the task, how long the task should take and additional parameters passed in by the client as arguments.  The  initial temperature, cooling rate and number of iterations per change in temperature that are detrimental to the SA algorithm are not given and are all chosen on the executor side. See the executor document for details.\n\n\nThe MagellanFramework then uses Fenzo to determine how tasks will be scheduled and then uses the Mesos Driver to schedule the tasks. See the Scheduler docs for more details.\n\n\nThe response from the executor is the following JSON string:\n\n\n{\n    \nuid\n:\n    # for anneal\n    \nbest_location\n:\n    \nfitness_score\n:\n    # for divisions\n    \ndivisions\n:\n}\n\n\n\n\nThis JSON string cotains the unique identifier for the task, the best solution it discovered, and the fitness or energy score of the best solution. This data is passed to and processed by the MagellanJob from which it originated.  If the energy of this data is better than the global best energy, then we update our global best fitness value and location value. Currently, new tasks start their searches with the global best values but by the final product, we hope to implement a meta annealing scheduler where the scheduler itself performs simulated annealing to choose starting locations for new tasks.\n\n\nIn case of a failed task, the following body will be returned with a TASK_FAILED status:\n\n\n{\n    \nerror\n: \nstacktrace\n\n}", 
            "title": "Communication"
        }, 
        {
            "location": "/comm/#communication", 
            "text": "Description of the communication between the different components of the Magellan Mesos Framework.", 
            "title": "Communication"
        }, 
        {
            "location": "/comm/#the-scheduler-api-schema", 
            "text": "The following REST API schema is used by the Web UI to communicate with the scheduler back end.", 
            "title": "The Scheduler API Schema"
        }, 
        {
            "location": "/comm/#post-apijob", 
            "text": "Create a new job  Request  {\n     job_name  :  Solve 99 Problems ,\n     job_time  : 3600,\n     module_url  :  git@github.com:mesos-magellan/faleiro.git ,\n     module_data  : {\n         problem_size  : 99,\n         expected_solution  : 0,\n         anything_i_want  : {\n             all_my_things  : [\n                 cat ,\n                4096,\n                 dogs ,\n                 foo \n            ]\n        }\n    }\n}  Response (200)  {\n     job_id  : 42\n}  Response (422)  {\n     message  :  A parameter is missing \n}  Response (500)  {\n     message  :  Failed to create job \n}", 
            "title": "POST /api/job"
        }, 
        {
            "location": "/comm/#put-apijobjob_idstatus", 
            "text": "Set the status of an existing job  Parameters  {job_id}  :  ID of the job to modify  Request  {\n     status  :  resume  /* or  stop  or  pause  */\n}  Response (200)  {\n}  Response (422)  {\n     message  :  A parameter is missing \n}", 
            "title": "PUT /api/job/{job_id}/status"
        }, 
        {
            "location": "/comm/#get-apijobs", 
            "text": "Get all the jobs  Request  {\n}  Response (200)  {\n    [\n        {\n             job_id  : 42,\n             job_name  :  Solve 99 Problems ,\n             job_starting_time  : 112385801,\n             task_name  :  git@github.com:mesos-magellan/faleiro.git ,\n             task_seconds  : 500,\n             current_state  :  RUNNING ,\n             best_location  :  { \\ path\\  : \\ SUJENAGHWOPQ\\  } ,\n             best_energy  : 400.5,\n             num_finished_tasks  : 91,\n             num_total_tasks  : 99,\n             energy_history  : [\n                0.2,\n                400.5,\n                10.122\n            ],\n             additional_params  : {\n                 start  : {\n                     X  : 356,\n                     name  :  foo \n                }\n            }\n        },\n        {\n             job_id  : 47,\n             job_name  :  Solve All Problems ,\n             job_starting_time  : 112385801,\n             task_name  :  git@github.com:mesos-magellan/faleiro.git ,\n             task_seconds  : 600,\n             current_state  :  STOP ,\n             best_location  :  { \\ index\\  : 2345093 } ,\n             best_energy  : 12039454,\n             num_finished_tasks  : 42,\n             num_total_tasks  : 123,\n             energy_history  : [\n                947345,\n                3302,\n                12039454\n            ],\n             additional_params  : {\n                 start  : {\n                     X  : 50,\n                     name  :  hello world \n                }\n            }\n        }\n    ]\n}", 
            "title": "GET /api/jobs"
        }, 
        {
            "location": "/comm/#get-apijobjob_id", 
            "text": "Get a specific job by job_id  Parameters  {job_id}  :  ID of the job to retrieve  Request  {\n}  Response (200) - No longer running  Response (202) - Job still running  {\n     job_id  : 47,\n     job_name  :  Solve All Problems ,\n     job_starting_time  : 112385801,\n     task_name  :  git@github.com:mesos-magellan/faleiro.git ,\n     task_seconds  : 600,\n     current_state  :  STOP ,\n     best_location  :  { \\ index\\  : 2345093 } ,\n     best_energy  : 12039454,\n     num_finished_tasks  : 42,\n     num_total_tasks  : 123,\n     energy_history  : [\n        947345,\n        3302,\n        12039454\n    ],\n     additional_params  : {\n         start  : {\n             X  : 50,\n             name  :  hello world \n        }\n    }\n}  Response (422)  {\n     message  :  A parameter is missing \n}", 
            "title": "GET /api/job/{job_id}"
        }, 
        {
            "location": "/comm/#job-creation-to-executor", 
            "text": "", 
            "title": "Job Creation to Executor"
        }, 
        {
            "location": "/comm/#client-starts-job", 
            "text": "The client starts a job using the command line interface. Using the CLI, they can specify the parameters for their job. The full list of parameters can be found on the Web API page. After creating a job on the command line client, the request is sent to the Web API using http.", 
            "title": "Client Starts Job"
        }, 
        {
            "location": "/comm/#the-web-api", 
            "text": "The web api handles the request from the CLI and forwards this request to the MagellanFramework using the function call  MagellanFramework::createJob() .", 
            "title": "The Web API"
        }, 
        {
            "location": "/comm/#the-magellan-framework", 
            "text": "Internally, the Magellan Framework constructs a MagellanJob object. A MagellanJob, at a high level, represents all data and state corresponding to a problem that the client wants to solve. The MagellanJob breaks this problem into subproblems called tasks which are run on executors. An instance of the Magellan Framework can have multiple instances of MagellanJob with each instance having several tasks associated with it that can be run in parallel.  After creating the MagellanJob object, the framework calls  MagellanJob::start()  which executes the main function of the Job, called  MagellanJob::run() , in a separate thread.   A MagellanJob is responsible for partioning the search space of the problem and creating tasks which run on executors and report their results back to the job. MagellanJobs are restricted to creating 10 active tasks at a time to ensure that this system scales well when a lot of jobs are submitted simultaneously. New tasks are submitted to a BlockingQueue called  pendingTasks . This object holds ready tasks until the MagellanFramework requests them using the method  MagellanJob::getPendingTasks() . After executing tasks, the results are returned to the Job to be processed using the method,  MagellanJob::processIncomingMessages() .   The scheduler sends the following JSON string to the executor as part of the tasks payload:   {\n    # required\n     uid :\n     name :\n     command :\n     problem_data :\n    # for 'divisions' command\n     divisions :\n    # for 'anneal' command\n     sstates :\n     minutes_per_division :\n}  As you can see, each task only sends a unique identifier for the task, the starting location for the simulated annealing (SA) algorithm, the name of the SA implementation we want to use to execute the task, how long the task should take and additional parameters passed in by the client as arguments.  The  initial temperature, cooling rate and number of iterations per change in temperature that are detrimental to the SA algorithm are not given and are all chosen on the executor side. See the executor document for details.  The MagellanFramework then uses Fenzo to determine how tasks will be scheduled and then uses the Mesos Driver to schedule the tasks. See the Scheduler docs for more details.  The response from the executor is the following JSON string:  {\n     uid :\n    # for anneal\n     best_location :\n     fitness_score :\n    # for divisions\n     divisions :\n}  This JSON string cotains the unique identifier for the task, the best solution it discovered, and the fitness or energy score of the best solution. This data is passed to and processed by the MagellanJob from which it originated.  If the energy of this data is better than the global best energy, then we update our global best fitness value and location value. Currently, new tasks start their searches with the global best values but by the final product, we hope to implement a meta annealing scheduler where the scheduler itself performs simulated annealing to choose starting locations for new tasks.  In case of a failed task, the following body will be returned with a TASK_FAILED status:  {\n     error :  stacktrace \n}", 
            "title": "The Magellan Framework"
        }, 
        {
            "location": "/arch/", 
            "text": "Architecture", 
            "title": "Architecture"
        }, 
        {
            "location": "/arch/#architecture", 
            "text": "", 
            "title": "Architecture"
        }, 
        {
            "location": "/test/", 
            "text": "Testing\n\n\nUnit Testing\n\n\nScheduler\n\n\nThe scheduler has a suite of jUnit tests that are run on every push to GitHub and after building locally.\n\n\nPerformance Testing\n\n\nStress Test\n\n\nCreate many jobs over time\n\n\nSoak Test\n\n\nRun a few long jobs\n\n\nSpike Test\n\n\nCreate many jobs at once\n\n\nSolution Comparisons\n\n\nDistributed Simulated Annealing vs. Bruteforce\n\n\nDistributed Simulated Annealing vs. Locally Serial\n\n\nDistributed Simulated Annealing vs. Locally Parallel\n\n\nAccuracy Testing\n\n\nTo prove the accuracy of Magellan and Travelling Sailor, we ran a bruteforce solution to solving TSP for 10 cities. Magellan was able to find the same best fitness as the bruteforce solution. The fitness was measured as the geodesic diestance between the cities for a round trip back to the starting city. The best fitness found was \n28919.86893 km\n and the data used was:\n\n\n{\n\ncities\n: {\n   \nHolmesville\n: [31.7036111, -82.3208333],\n   \nJatipasir\n: [-8.2509, 113.9975],\n   \nTapalinna\n: [-2.923, 119.1626],\n   \nSahout el Ma\n: [16.9166667, -15.1666667],\n   \nIsanganaka\n: [-0.683333, 24.083333],\n   \nEl Yerbanis\n: [29.45, -108.6],\n   \nGun-ob\n: [9.6289, 124.0517],\n   \nChak Seventy-five ML\n: [31.345362, 71.123454],\n   \nBakous\n: [13.7363889, -16.6080556],\n   \nMetkow Maly\n: [50.05, 19.4]\n},\n\nupdates_enabled\n: false,\n\nstart_city\n: \nBakous\n\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/test/#testing", 
            "text": "", 
            "title": "Testing"
        }, 
        {
            "location": "/test/#unit-testing", 
            "text": "", 
            "title": "Unit Testing"
        }, 
        {
            "location": "/test/#scheduler", 
            "text": "The scheduler has a suite of jUnit tests that are run on every push to GitHub and after building locally.", 
            "title": "Scheduler"
        }, 
        {
            "location": "/test/#performance-testing", 
            "text": "", 
            "title": "Performance Testing"
        }, 
        {
            "location": "/test/#stress-test", 
            "text": "Create many jobs over time", 
            "title": "Stress Test"
        }, 
        {
            "location": "/test/#soak-test", 
            "text": "Run a few long jobs", 
            "title": "Soak Test"
        }, 
        {
            "location": "/test/#spike-test", 
            "text": "Create many jobs at once", 
            "title": "Spike Test"
        }, 
        {
            "location": "/test/#solution-comparisons", 
            "text": "", 
            "title": "Solution Comparisons"
        }, 
        {
            "location": "/test/#distributed-simulated-annealing-vs-bruteforce", 
            "text": "", 
            "title": "Distributed Simulated Annealing vs. Bruteforce"
        }, 
        {
            "location": "/test/#distributed-simulated-annealing-vs-locally-serial", 
            "text": "", 
            "title": "Distributed Simulated Annealing vs. Locally Serial"
        }, 
        {
            "location": "/test/#distributed-simulated-annealing-vs-locally-parallel", 
            "text": "", 
            "title": "Distributed Simulated Annealing vs. Locally Parallel"
        }, 
        {
            "location": "/test/#accuracy-testing", 
            "text": "To prove the accuracy of Magellan and Travelling Sailor, we ran a bruteforce solution to solving TSP for 10 cities. Magellan was able to find the same best fitness as the bruteforce solution. The fitness was measured as the geodesic diestance between the cities for a round trip back to the starting city. The best fitness found was  28919.86893 km  and the data used was:  { cities : {\n    Holmesville : [31.7036111, -82.3208333],\n    Jatipasir : [-8.2509, 113.9975],\n    Tapalinna : [-2.923, 119.1626],\n    Sahout el Ma : [16.9166667, -15.1666667],\n    Isanganaka : [-0.683333, 24.083333],\n    El Yerbanis : [29.45, -108.6],\n    Gun-ob : [9.6289, 124.0517],\n    Chak Seventy-five ML : [31.345362, 71.123454],\n    Bakous : [13.7363889, -16.6080556],\n    Metkow Maly : [50.05, 19.4]\n}, updates_enabled : false, start_city :  Bakous \n}", 
            "title": "Accuracy Testing"
        }, 
        {
            "location": "/demo/", 
            "text": "Magellan Demo (Travelling Sailor)\n\n\nDescription of the travelling sailor demo.", 
            "title": "Demo"
        }, 
        {
            "location": "/demo/#magellan-demo-travelling-sailor", 
            "text": "Description of the travelling sailor demo.", 
            "title": "Magellan Demo (Travelling Sailor)"
        }, 
        {
            "location": "/guide/", 
            "text": "How to use Magellan\n\n\nAn explanation on how to write and use a module for Magellan to solve your problem.\n\n\nCreating a job via the Web UI\n\n\n\n\nNavigate to the \"Create a Job\" page by clicking the link on the top-right of the homepage.\n\n\nEnter a descriptive indentifying name for the job, (eg. Traveling Sailor).\n\n\nEnter how many minutes of CPU time (not real time) you want the job to run for, (eg. 40).\n\n\nEnter a URL to a GIT repository or a downloadable tarball (.tar.gz), (eg. git://github.com/mesos-magellan/traveling-sailor).\n\n\nEnter any additional data in JSON format you want to be passed on to your module. (Example for traveling-sailor at the end of this section).\n\n\nPress the \"Create Job\" button, you will then be forwarded to the \"Job Details\" page for your newly created job.\n\n\n\n\nModule JSON data example for traveling-sailor:\n\n\n{\n\ncities\n: {\n   \nHolmesville\n: [31.7036111, -82.3208333],\n   \nJatipasir\n: [-8.2509, 113.9975],\n   \nTapalinna\n: [-2.923, 119.1626],\n   \nSahout el Ma\n: [16.9166667, -15.1666667],\n   \nIsanganaka\n: [-0.683333, 24.083333],\n   \nEl Yerbanis\n: [29.45, -108.6],\n   \nGun-ob\n: [9.6289, 124.0517],\n   \nChak Seventy-five ML\n: [31.345362, 71.123454],\n   \nBakous\n: [13.7363889, -16.6080556],\n   \nMetkow Maly\n: [50.05, 19.4]\n},\n\nupdates_enabled\n: false,\n\nstart_city\n: \nBakous\n\n}", 
            "title": "Guides"
        }, 
        {
            "location": "/guide/#how-to-use-magellan", 
            "text": "An explanation on how to write and use a module for Magellan to solve your problem.", 
            "title": "How to use Magellan"
        }, 
        {
            "location": "/guide/#creating-a-job-via-the-web-ui", 
            "text": "Navigate to the \"Create a Job\" page by clicking the link on the top-right of the homepage.  Enter a descriptive indentifying name for the job, (eg. Traveling Sailor).  Enter how many minutes of CPU time (not real time) you want the job to run for, (eg. 40).  Enter a URL to a GIT repository or a downloadable tarball (.tar.gz), (eg. git://github.com/mesos-magellan/traveling-sailor).  Enter any additional data in JSON format you want to be passed on to your module. (Example for traveling-sailor at the end of this section).  Press the \"Create Job\" button, you will then be forwarded to the \"Job Details\" page for your newly created job.   Module JSON data example for traveling-sailor:  { cities : {\n    Holmesville : [31.7036111, -82.3208333],\n    Jatipasir : [-8.2509, 113.9975],\n    Tapalinna : [-2.923, 119.1626],\n    Sahout el Ma : [16.9166667, -15.1666667],\n    Isanganaka : [-0.683333, 24.083333],\n    El Yerbanis : [29.45, -108.6],\n    Gun-ob : [9.6289, 124.0517],\n    Chak Seventy-five ML : [31.345362, 71.123454],\n    Bakous : [13.7363889, -16.6080556],\n    Metkow Maly : [50.05, 19.4]\n}, updates_enabled : false, start_city :  Bakous \n}", 
            "title": "Creating a job via the Web UI"
        }
    ]
}