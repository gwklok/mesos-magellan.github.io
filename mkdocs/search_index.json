{
    "docs": [
        {
            "location": "/", 
            "text": "Magellan\n\n\nA Mesos framework for Distributed Simulated Annealing.\n\n\nComponents\n\n\nFaleiro (The Scheduler)\n\n\nEnrique (The Executor)\n\n\nMiguel (The Scheduler CLI)\n\n\nVictoria (Development Environment)\n\n\nTraveling Sailor (TSP Solver using Simulated Annealing)\n\n\nCircumnavigator (Web User Interface)", 
            "title": "Home"
        }, 
        {
            "location": "/#magellan", 
            "text": "A Mesos framework for Distributed Simulated Annealing.", 
            "title": "Magellan"
        }, 
        {
            "location": "/#components", 
            "text": "Faleiro (The Scheduler)  Enrique (The Executor)  Miguel (The Scheduler CLI)  Victoria (Development Environment)  Traveling Sailor (TSP Solver using Simulated Annealing)  Circumnavigator (Web User Interface)", 
            "title": "Components"
        }, 
        {
            "location": "/webapi/", 
            "text": "POST /api/job\n\n\nCreate a new job\n\n\nRequest\n\n\n{\n    \njob_name\n : \nSolve 99 Problems\n,\n    \njob_init_temp\n : 200,\n    \njob_init_cooling_rate\n : 0.2,\n    \njob_iterations_per_temp\n : 100000,\n    \ntask_time\n : 3600,\n    \ntask_name\n : \ntraveling_sailor\n,\n    \njob_data\n : {\n        \nproblem_size\n : 99,\n        \nexpected_solution\n : 0,\n        \nanything_i_want\n : {\n            \nall_my_things\n : [\n                \ncat\n,\n                4096,\n                \ndogs\n,\n                \nfoo\n\n            ]\n        }\n    }\n}\n\n\n\n\nResponse (200)\n\n\n{\n    \njob_id\n : 42\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}\n\n\n\n\nResponse (500)\n\n\n{\n    \nmessage\n : \nFailed to create job\n\n}\n\n\n\n\nPUT /api/job/{job_id}/status\n\n\nSet the status of an existing job\n\n\nParameters\n\n\n{job_id}\n : \nID of the job to modify\n\n\nRequest\n\n\n{\n    \nstatus\n : \nresume\n /* or \nstop\n or \npause\n */\n}\n\n\n\n\nResponse (200)\n\n\n{\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}\n\n\n\n\nGET /api/jobs\n\n\nGet all the jobs\n\n\nRequest\n\n\n{\n}\n\n\n\n\nResponse (200)\n\n\n{\n    [\n        {\n            \njob_id\n : 42,\n            \njob_name\n : \nSolve 99 Problems\n,\n            \njob_starting_temp\n : 200,\n            \njob_cooling_rate\n : 0.2,\n            \njob_count\n : 10,\n            \ntask_starting_temp\n : 100,\n            \ntask_cooling_rate\n : 0.1,\n            \ntask_count\n : 10,\n            \nbest_location\n : \n{ \\\npath\\\n : \\\nSUJENAGHWOPQ\\\n }\n,\n            \nbest_energy\n : 400.5,\n            \nenergy_history\n : [\n                0.2,\n                400.5,\n                10.122\n            ]\n        },\n        {\n            \njob_id\n : 47,\n            \njob_name\n : \nSolve All Problems\n,\n            \njob_starting_temp\n : 250,\n            \njob_cooling_rate\n : 0.6,\n            \njob_count\n : 32,\n            \ntask_starting_temp\n : 80,\n            \ntask_cooling_rate\n : 0.8,\n            \ntask_count\n : 100,\n            \nbest_location\n : \n{ \\\nindex\\\n : 2345093 }\n,\n            \nbest_energy\n : 12039454,\n            \nenergy_history\n : [\n                947345,\n                3302,\n                12039454\n            ]\n        }\n    ]\n}\n\n\n\n\nGET /api/job/{job_id}\n\n\nGet a specific job by job_id\n\n\nParameters\n\n\n{job_id}\n : \nID of the job to retrieve\n\n\nRequest\n\n\n{\n}\n\n\n\n\nResponse (200) - No longer running\n\n\nResponse (202) - Job still running\n\n\n{\n    \njob_id\n : 42,\n    \njob_name\n : \nSolve 99 Problems\n,\n    \njob_starting_temp\n : 200,\n    \njob_cooling_rate\n : 0.2,\n    \njob_count\n : 10,\n    \ntask_starting_temp\n : 100,\n    \ntask_cooling_rate\n : 0.1,\n    \ntask_count\n : 10,\n    \nbest_location\n : \n{ \\\npath\\\n : \\\nSUJENAGHWOPQ\\\n }\n,\n    \nbest_energy\n : 400.5,\n    \nenergy_history\n : [\n        0.2,\n        400.5,\n        10.122\n    ]\n}\n\n\n\n\nResponse (422)\n\n\n{\n    \nmessage\n : \nA parameter is missing\n\n}", 
            "title": "Web API Schema"
        }, 
        {
            "location": "/webapi/#post-apijob", 
            "text": "Create a new job  Request  {\n     job_name  :  Solve 99 Problems ,\n     job_init_temp  : 200,\n     job_init_cooling_rate  : 0.2,\n     job_iterations_per_temp  : 100000,\n     task_time  : 3600,\n     task_name  :  traveling_sailor ,\n     job_data  : {\n         problem_size  : 99,\n         expected_solution  : 0,\n         anything_i_want  : {\n             all_my_things  : [\n                 cat ,\n                4096,\n                 dogs ,\n                 foo \n            ]\n        }\n    }\n}  Response (200)  {\n     job_id  : 42\n}  Response (422)  {\n     message  :  A parameter is missing \n}  Response (500)  {\n     message  :  Failed to create job \n}", 
            "title": "POST /api/job"
        }, 
        {
            "location": "/webapi/#put-apijobjob_idstatus", 
            "text": "Set the status of an existing job  Parameters  {job_id}  :  ID of the job to modify  Request  {\n     status  :  resume  /* or  stop  or  pause  */\n}  Response (200)  {\n}  Response (422)  {\n     message  :  A parameter is missing \n}", 
            "title": "PUT /api/job/{job_id}/status"
        }, 
        {
            "location": "/webapi/#get-apijobs", 
            "text": "Get all the jobs  Request  {\n}  Response (200)  {\n    [\n        {\n             job_id  : 42,\n             job_name  :  Solve 99 Problems ,\n             job_starting_temp  : 200,\n             job_cooling_rate  : 0.2,\n             job_count  : 10,\n             task_starting_temp  : 100,\n             task_cooling_rate  : 0.1,\n             task_count  : 10,\n             best_location  :  { \\ path\\  : \\ SUJENAGHWOPQ\\  } ,\n             best_energy  : 400.5,\n             energy_history  : [\n                0.2,\n                400.5,\n                10.122\n            ]\n        },\n        {\n             job_id  : 47,\n             job_name  :  Solve All Problems ,\n             job_starting_temp  : 250,\n             job_cooling_rate  : 0.6,\n             job_count  : 32,\n             task_starting_temp  : 80,\n             task_cooling_rate  : 0.8,\n             task_count  : 100,\n             best_location  :  { \\ index\\  : 2345093 } ,\n             best_energy  : 12039454,\n             energy_history  : [\n                947345,\n                3302,\n                12039454\n            ]\n        }\n    ]\n}", 
            "title": "GET /api/jobs"
        }, 
        {
            "location": "/webapi/#get-apijobjob_id", 
            "text": "Get a specific job by job_id  Parameters  {job_id}  :  ID of the job to retrieve  Request  {\n}  Response (200) - No longer running  Response (202) - Job still running  {\n     job_id  : 42,\n     job_name  :  Solve 99 Problems ,\n     job_starting_temp  : 200,\n     job_cooling_rate  : 0.2,\n     job_count  : 10,\n     task_starting_temp  : 100,\n     task_cooling_rate  : 0.1,\n     task_count  : 10,\n     best_location  :  { \\ path\\  : \\ SUJENAGHWOPQ\\  } ,\n     best_energy  : 400.5,\n     energy_history  : [\n        0.2,\n        400.5,\n        10.122\n    ]\n}  Response (422)  {\n     message  :  A parameter is missing \n}", 
            "title": "GET /api/job/{job_id}"
        }, 
        {
            "location": "/scheduler/", 
            "text": "Faleiro\n\n\nFaleiro is the code name for our scheduler. Our scheduler is controlled from our web api and is responsible for accepting resource offers from the Mesos master, collecting tasks to be scheduled from active jobs, and choosing and running a subset of these jobs on availble resource offers. \n\n\nUsing Resource Offers\n\n\nMesos master sends resource offers to the scheduler by calling \nMagellanFramework::resourceOffers()\n which stores the resource offers in a \nBlockingQueue\n which is accessed by Fenzo later.  \n\n\nPicking Parameters for New Tasks\n\n\nThe scheduler tells each executor the starting parameters for its simulated annealing algorithm. These parameters are formatted as a json string and include information such as the starting location to start the search, data passed in by the client using the command line client, and the name of the specific task we want to import on the executor side (see documentation on executor). The full json list is shown in the Job to Executor document. , and the length of time that we want the executor to run for. The  Initial temperature, cooling rate and number of iterations per change in temperature are all chosen on the executor side.\n\n\nFenzo\n\n\nFenzo is a library provided by Netflix that manages the scheduling and resource managment of tasks we want to execute. On each run of the MagellanFramework main loop, the framework invokes Fenzo by calling \nTaskScheduler::scheduleOnce()\n and providing it with a list of resource offers and tasks. The resource offers are taken from the queue where they were placed by \nMagellanFramework::resourceOffers()\n. The list of tasks to run is attained by calling \nMagellanJob::getPendingTasks()\n. If resource offers are not used by fenzo, it keeps hold of them and are used on the next call to \nTaskScheduler::scheduleOnce()\n.\n\n\nFramework Main Loop\n\n\nThe main loop of the MagellanFramework is run in a separate thread which calls the function \nMagellanFramework::runFramework()\n. This function first loops through the list of running jobs in the system and calls \nMagellanJob::getPendingTasks()\n on each job to get a list of tasks it wants to schedule. It then gives this list to Fenzo by calling \nTaskScheduler::scheduleOnce()\n and receives a mapping between resource offers and tasks. If some of the tasks are not selected to be scheduled by Fenzo, then the remaining tasks are retained by the Framework and are submitted to Fenzo again during the next iteration. \n\n\nAfter receiving the scheduling suggestions by Fenzo,the the framework then prepares each task by creating a \nTaskInfo\n object which contains information such as the slave ID and task data. Tasks are scheduled on a per Host (node) basis. Hosts are specified using the \nVMAssignmentResult\n object and can offer multiple resource offers (called \nleases\n in the code). A list of all TaskInfo object for each host is created in an object called \ntaskInfos\n. Additionally, a list of all the resource offer ids that will be used on the particular host are created and stored in a list called \nofferIDs\n. Once the \ntaskInfos\n and \nofferIDs\n objects are populated, they are submitted to the mesos driver using the method, \nMesosSchedulerDriver::launchTasks()\n. The mesos driver is responsible for getting the tasks to their corresponding executor.", 
            "title": "Faleiro"
        }, 
        {
            "location": "/scheduler/#faleiro", 
            "text": "Faleiro is the code name for our scheduler. Our scheduler is controlled from our web api and is responsible for accepting resource offers from the Mesos master, collecting tasks to be scheduled from active jobs, and choosing and running a subset of these jobs on availble resource offers.", 
            "title": "Faleiro"
        }, 
        {
            "location": "/scheduler/#using-resource-offers", 
            "text": "Mesos master sends resource offers to the scheduler by calling  MagellanFramework::resourceOffers()  which stores the resource offers in a  BlockingQueue  which is accessed by Fenzo later.", 
            "title": "Using Resource Offers"
        }, 
        {
            "location": "/scheduler/#picking-parameters-for-new-tasks", 
            "text": "The scheduler tells each executor the starting parameters for its simulated annealing algorithm. These parameters are formatted as a json string and include information such as the starting location to start the search, data passed in by the client using the command line client, and the name of the specific task we want to import on the executor side (see documentation on executor). The full json list is shown in the Job to Executor document. , and the length of time that we want the executor to run for. The  Initial temperature, cooling rate and number of iterations per change in temperature are all chosen on the executor side.", 
            "title": "Picking Parameters for New Tasks"
        }, 
        {
            "location": "/scheduler/#fenzo", 
            "text": "Fenzo is a library provided by Netflix that manages the scheduling and resource managment of tasks we want to execute. On each run of the MagellanFramework main loop, the framework invokes Fenzo by calling  TaskScheduler::scheduleOnce()  and providing it with a list of resource offers and tasks. The resource offers are taken from the queue where they were placed by  MagellanFramework::resourceOffers() . The list of tasks to run is attained by calling  MagellanJob::getPendingTasks() . If resource offers are not used by fenzo, it keeps hold of them and are used on the next call to  TaskScheduler::scheduleOnce() .", 
            "title": "Fenzo"
        }, 
        {
            "location": "/scheduler/#framework-main-loop", 
            "text": "The main loop of the MagellanFramework is run in a separate thread which calls the function  MagellanFramework::runFramework() . This function first loops through the list of running jobs in the system and calls  MagellanJob::getPendingTasks()  on each job to get a list of tasks it wants to schedule. It then gives this list to Fenzo by calling  TaskScheduler::scheduleOnce()  and receives a mapping between resource offers and tasks. If some of the tasks are not selected to be scheduled by Fenzo, then the remaining tasks are retained by the Framework and are submitted to Fenzo again during the next iteration.   After receiving the scheduling suggestions by Fenzo,the the framework then prepares each task by creating a  TaskInfo  object which contains information such as the slave ID and task data. Tasks are scheduled on a per Host (node) basis. Hosts are specified using the  VMAssignmentResult  object and can offer multiple resource offers (called  leases  in the code). A list of all TaskInfo object for each host is created in an object called  taskInfos . Additionally, a list of all the resource offer ids that will be used on the particular host are created and stored in a list called  offerIDs . Once the  taskInfos  and  offerIDs  objects are populated, they are submitted to the mesos driver using the method,  MesosSchedulerDriver::launchTasks() . The mesos driver is responsible for getting the tasks to their corresponding executor.", 
            "title": "Framework Main Loop"
        }, 
        {
            "location": "/webapitosched/", 
            "text": "Web API Communication With Scheduler\n\n\nCreating a Job\n\n\nThe Web API receives input as documented on the Web API Schema page. It then validates user input as necessary and forwards the input to an instance of the scheduler framework. To create a job, the API forwards the parameters to the \nMagellanFramework::createJob()\n method which then returns the created job's ID and returns it to the user making the API request.\n\n\nGetting Job Status\n\n\nWhen the user requests data about the running jobs, the web API calls the \nMagellanFramework::getJobStatus()\n and \nMagellanFramework::getAllJobStatuses()\n methods for a specific job and for all jobs, respectively. The method calls provide all the info about a job which is then returned to the user.\n\n\nManage a Job\n\n\nThe Web API is able to pause, resume, and stop a job. The user makes a request and specificies which action they would like to take. The Web API then makes the appropriate method call to the scheduler framework: \nMagellanFramework::pauseJob()\n, \nMagellanFramework::resumeJob()\n, and \nMagellanFramework::stopJob()\n.", 
            "title": "Web API to Scheduler"
        }, 
        {
            "location": "/webapitosched/#web-api-communication-with-scheduler", 
            "text": "", 
            "title": "Web API Communication With Scheduler"
        }, 
        {
            "location": "/webapitosched/#creating-a-job", 
            "text": "The Web API receives input as documented on the Web API Schema page. It then validates user input as necessary and forwards the input to an instance of the scheduler framework. To create a job, the API forwards the parameters to the  MagellanFramework::createJob()  method which then returns the created job's ID and returns it to the user making the API request.", 
            "title": "Creating a Job"
        }, 
        {
            "location": "/webapitosched/#getting-job-status", 
            "text": "When the user requests data about the running jobs, the web API calls the  MagellanFramework::getJobStatus()  and  MagellanFramework::getAllJobStatuses()  methods for a specific job and for all jobs, respectively. The method calls provide all the info about a job which is then returned to the user.", 
            "title": "Getting Job Status"
        }, 
        {
            "location": "/webapitosched/#manage-a-job", 
            "text": "The Web API is able to pause, resume, and stop a job. The user makes a request and specificies which action they would like to take. The Web API then makes the appropriate method call to the scheduler framework:  MagellanFramework::pauseJob() ,  MagellanFramework::resumeJob() , and  MagellanFramework::stopJob() .", 
            "title": "Manage a Job"
        }, 
        {
            "location": "/jobcreationtoexec/", 
            "text": "Job Creation to Executor\n\n\nClient Starts Job\n\n\nThe client starts a job using the command line interface. Using the CLI, they can specify the parameters for their job. The full list of parameters can be found on the Web API page. After creating a job on the command line client, the request is sent to the Web API using http.\n\n\nThe Web API\n\n\nThe web api handles the request from the CLI and forwards this request to the MagellanFramework using the function call \nMagellanFramework::createJob()\n. \n\n\nThe Magellan Framework\n\n\nInternally, the Magellan Framework constructs a MagellanJob object. A MagellanJob, at a high level, represents all data and state corresponding to a problem that the client wants to solve. The MagellanJob breaks this problem into subproblems called tasks which are run on executors. An instance of the Magellan Framework can have multiple instances of MagellanJob with each instance having several tasks associated with it that can be run in parallel.  After creating the MagellanJob object, the framework calls \nMagellanJob::start()\n which executes the main function of the Job, called \nMagellanJob::run()\n, in a separate thread. \n\n\nA MagellanJob is responsible for partioning the search space of the problem and creating tasks which run on executors and report their results back to the job. MagellanJobs are restricted to creating 10 active tasks at a time to ensure that this system scales well when a lot of jobs are submitted simultaneously. New tasks are submitted to a BlockingQueue called \npendingTasks\n. This object holds ready tasks until the MagellanFramework requests them using the method \nMagellanJob::getPendingTasks()\n. After executing tasks, the results are returned to the Job to be processed using the method, \nMagellanJob::processIncomingMessages()\n. \n\n\nThe scheduler sends the following JSON string to the executor as part of the tasks payload: \n\n\n{\n    # required\n    \nuid\n:\n    \nname\n:\n    \ncommand\n:\n    \nproblem_data\n:\n    # for 'divisions' command\n    \ndivisions\n:\n    # for 'anneal' command\n    \nsstates\n:\n    \nminutes_per_division\n:\n}\n\n\n\n\nAs you can see, each task only sends a unique identifier for the task, the starting location for the simulated annealing (SA) algorithm, the name of the SA implementation we want to use to execute the task, how long the task should take and additional parameters passed in by the client as arguments.  The  initial temperature, cooling rate and number of iterations per change in temperature that are detrimental to the SA algorithm are not given and are all chosen on the executor side. See the executor document for details.\n\n\nThe MagellanFramework then uses Fenzo to determine how tasks will be scheduled and then uses the Mesos Driver to schedule the tasks. See the Scheduler docs for more details.\n\n\nThe response from the executor is the following JSON string:\n\n\n{\n    \nuid\n:\n    # for anneal\n    \nbest_location\n:\n    \nfitness_score\n:\n    # for divisions\n    \ndivisions\n:\n}\n\n\n\n\nThis JSON string cotains the unique identifier for the task, the best solution it discovered, and the fitness or energy score of the best solution. This data is passed to and processed by the MagellanJob from which it originated.  If the energy of this data is better than the global best energy, then we update our global best fitness value and location value. Currently, new tasks start their searches with the global best values but by the final product, we hope to implement a meta annealing scheduler where the scheduler itself performs simulated annealing to choose starting locations for new tasks.", 
            "title": "Job Creation to Executor"
        }, 
        {
            "location": "/jobcreationtoexec/#job-creation-to-executor", 
            "text": "", 
            "title": "Job Creation to Executor"
        }, 
        {
            "location": "/jobcreationtoexec/#client-starts-job", 
            "text": "The client starts a job using the command line interface. Using the CLI, they can specify the parameters for their job. The full list of parameters can be found on the Web API page. After creating a job on the command line client, the request is sent to the Web API using http.", 
            "title": "Client Starts Job"
        }, 
        {
            "location": "/jobcreationtoexec/#the-web-api", 
            "text": "The web api handles the request from the CLI and forwards this request to the MagellanFramework using the function call  MagellanFramework::createJob() .", 
            "title": "The Web API"
        }, 
        {
            "location": "/jobcreationtoexec/#the-magellan-framework", 
            "text": "Internally, the Magellan Framework constructs a MagellanJob object. A MagellanJob, at a high level, represents all data and state corresponding to a problem that the client wants to solve. The MagellanJob breaks this problem into subproblems called tasks which are run on executors. An instance of the Magellan Framework can have multiple instances of MagellanJob with each instance having several tasks associated with it that can be run in parallel.  After creating the MagellanJob object, the framework calls  MagellanJob::start()  which executes the main function of the Job, called  MagellanJob::run() , in a separate thread.   A MagellanJob is responsible for partioning the search space of the problem and creating tasks which run on executors and report their results back to the job. MagellanJobs are restricted to creating 10 active tasks at a time to ensure that this system scales well when a lot of jobs are submitted simultaneously. New tasks are submitted to a BlockingQueue called  pendingTasks . This object holds ready tasks until the MagellanFramework requests them using the method  MagellanJob::getPendingTasks() . After executing tasks, the results are returned to the Job to be processed using the method,  MagellanJob::processIncomingMessages() .   The scheduler sends the following JSON string to the executor as part of the tasks payload:   {\n    # required\n     uid :\n     name :\n     command :\n     problem_data :\n    # for 'divisions' command\n     divisions :\n    # for 'anneal' command\n     sstates :\n     minutes_per_division :\n}  As you can see, each task only sends a unique identifier for the task, the starting location for the simulated annealing (SA) algorithm, the name of the SA implementation we want to use to execute the task, how long the task should take and additional parameters passed in by the client as arguments.  The  initial temperature, cooling rate and number of iterations per change in temperature that are detrimental to the SA algorithm are not given and are all chosen on the executor side. See the executor document for details.  The MagellanFramework then uses Fenzo to determine how tasks will be scheduled and then uses the Mesos Driver to schedule the tasks. See the Scheduler docs for more details.  The response from the executor is the following JSON string:  {\n     uid :\n    # for anneal\n     best_location :\n     fitness_score :\n    # for divisions\n     divisions :\n}  This JSON string cotains the unique identifier for the task, the best solution it discovered, and the fitness or energy score of the best solution. This data is passed to and processed by the MagellanJob from which it originated.  If the energy of this data is better than the global best energy, then we update our global best fitness value and location value. Currently, new tasks start their searches with the global best values but by the final product, we hope to implement a meta annealing scheduler where the scheduler itself performs simulated annealing to choose starting locations for new tasks.", 
            "title": "The Magellan Framework"
        }, 
        {
            "location": "/webui/", 
            "text": "The Web User Interface (Circumnavigator)\n\n\nThe Web User Interface (UI) allows users to create, manage, and monitor jobs. It is built using jQuery, Bootstrap and pure.js. To connect to the scheduler API, AJAX calls are made to create, modify and retrieve jobs. Bootstrap was used for quick styling and ensuring consistent functionality and appearence across different devices and browsers. pure.js allowed for templating HTML code with scheduler API data.\n\n\nThere are 3 pages to the web UI: Job List (home page), Create a Job, and Job Details. Each page has its own JavaScript file in the js folder, as well as a global script file: script.js, which holds global functions and data. The job list and job details pages auto-refresh periodically to keep the user updated with accurate information. The create a job page validates the user's input, providing feedback on incorrect fields, and redirects the user to the job details page for the job they create.\n\n\nState-based colour feedback is used throughout the UI. Based on the status of the job, different elements will have different colours or be hidden. The progress bar's appearance differs based on state in colour, animation, and style. When the job is in a state that could allow for completion (RUNNING or PAUSED), the progress bar is animated with moving stripes. When the job is in a state where it is incomplete and will not be able to be completed (STOP or FAILED), the progress bar is no longer animated but is still striped. Once the job is DONE, the progress bar is a solid green. The progress bars have a minimum width to correctly display the progress percentage when the values are low. The action buttons on the job details page are dynamic to the state as well. Their colours correspond to the actions they perform and will be hidden if their action is not valid for the current state.\n\n\nThe job list is ordered from newest to oldest descending with all stored jobs being displayed. The status and progress bars are styled as described above.", 
            "title": "Web UI"
        }, 
        {
            "location": "/webui/#the-web-user-interface-circumnavigator", 
            "text": "The Web User Interface (UI) allows users to create, manage, and monitor jobs. It is built using jQuery, Bootstrap and pure.js. To connect to the scheduler API, AJAX calls are made to create, modify and retrieve jobs. Bootstrap was used for quick styling and ensuring consistent functionality and appearence across different devices and browsers. pure.js allowed for templating HTML code with scheduler API data.  There are 3 pages to the web UI: Job List (home page), Create a Job, and Job Details. Each page has its own JavaScript file in the js folder, as well as a global script file: script.js, which holds global functions and data. The job list and job details pages auto-refresh periodically to keep the user updated with accurate information. The create a job page validates the user's input, providing feedback on incorrect fields, and redirects the user to the job details page for the job they create.  State-based colour feedback is used throughout the UI. Based on the status of the job, different elements will have different colours or be hidden. The progress bar's appearance differs based on state in colour, animation, and style. When the job is in a state that could allow for completion (RUNNING or PAUSED), the progress bar is animated with moving stripes. When the job is in a state where it is incomplete and will not be able to be completed (STOP or FAILED), the progress bar is no longer animated but is still striped. Once the job is DONE, the progress bar is a solid green. The progress bars have a minimum width to correctly display the progress percentage when the values are low. The action buttons on the job details page are dynamic to the state as well. Their colours correspond to the actions they perform and will be hidden if their action is not valid for the current state.  The job list is ordered from newest to oldest descending with all stored jobs being displayed. The status and progress bars are styled as described above.", 
            "title": "The Web User Interface (Circumnavigator)"
        }
    ]
}